---
title: C语言内存对齐学习记录
date: 2026-02-20 20:18:37
tags: C/C++
---
这是在阅读 lvgl 的链表源码时，从发现的疑问中一点点查询资料，询问 AI 后总结的笔记，感觉颇有收获。

## 内存对齐规则

1. 基本数据类型的对齐规则：每个数据类型都有一个对齐要求（或称 地址对齐值，可以通过 `alignof()` 语句获取），通常等于该数据类型占用的内存大小（可以通过 `sizeof()` 语句获取）。如 `int` 类型的变量占用 4 字节，所以需要在 4 字节对齐（4 的整数倍）的地址上存储。而且因为大部分数据类型的大小都是 2 的幂次方字节，所以地址对齐数也会是 2 的幂次方（特例： `long double` 在大部分 32 位平台上的大小是 8 字节，所以地址对齐数也是 8 字节；在大部分 64 位平台上的大小是 16 字节，所以地址对齐数也是 16 字节。但是在部分 32 位平台，如 `i686` 平台， `long double` 的大小是 12 字节，而地址对齐数却是 4 字节，这也是因为要遵循地址对齐数是 2 的幂次方字节的规则，因为这样进行内存分配时才会容易一些，比如下面会提到的 `malloc` 函数的原理）。

2. 结构体的对齐规则：
    1. 结构体中第一个数据成员存放的地址为与结构体的基地址偏移量为 0 的地址处。
    2. 其他结构体成员自身对齐时，存放的地址为 `min（自身对齐值, 指定对齐值）` 的最小整数倍的地址处。自身对齐值就是上面提到的这个成员变量自身的对齐要求；指定对齐值是宏 `#pragma pack(N)` 指定的值，这里面的 N 一定是 2 的幂次方，如 1，2，4，8，16 等（这个宏只影响结构体及其成员，不影响普通变量，即使定义了 `#pragma pack(2)`，独立的 int 变量的对齐值依然是 4）。如果没有通过宏来定义，那么 在 VS 环境中默认为 8，Linux gcc 无默认值。
    3. 结构体总大小为结构体成员变量中最大对齐值的整数倍，如：

        ``` c
        typedef struct test0
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            char c2;    //对齐到基地址偏移量 1，占用 1。
            int i1;     //对齐到基地址偏移量 4，占用 4。
        } test0;        //实际大小为 8。

        ```

        调整了结构体成员的排列顺序：

        ``` c
        typedef struct test1
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            int i1;     //对齐到基地址偏移量 4，占用 4。
            char c2;    //对齐到基地址偏移量 8，占用 1。
        } test1;        //理论大小为 9，但需要是 4 的整数倍，实际大小为 12。
        ```

        如果通过宏修改了指定对齐值：

        ``` c
        #pragma pack(2)
        typedef struct test1
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            int i1;     //对齐到基地址偏移量 2，占用 4。
            char c2;    //对齐到基地址偏移量 6，占用 1。
        } test1;        //理论大小为 7，但需要是 2 的整数倍，实际大小为 8。
        ```

    4. 结构体变量的基地址的对齐规则与普通数据类型一样，也需要对齐到它的自身对齐值的整数倍上，结构体的自身对齐值是它的所有成员变量的实际对齐值中的最大值。当结构体被更大的结构体嵌套时，小结构体地址相对于大结构体基地址的偏移量的计算方式与普通变量一致：`min（自身对齐值, 指定对齐值）` 的最小整数倍，如：

        ``` c
        typedef struct test2
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            test1 t1;   //test1 的成员中，实际对齐值的最大值是 i1 的 4，所以自身对齐值是 4。对齐到基地址偏移量 4，占用 12。
        } test2;        //test2 的成员中，实际对齐值的最大值是 t1 的 4，所以它的自身对齐值也是 4；理论大小为 13，但需要是 4 的整数倍，实际大小为 16。
        ```

        如果通过宏修改了指定对齐值：

        ``` c
        #pragma pack(2)
        typedef struct test2
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            test1 t1;   //test1 的成员中，实际对齐值的最大值是 i1 的 2，所以自身对齐值是 2。对齐到基地址偏移量 2，占用 8。
        } test2;        //test2 的成员中，实际对齐值的最大值是 t1 的 2，所以它的自身对齐值也是 2；理论大小为 9，但需要是 2 的整数倍，实际大小为 10。
        ```

3. 可以使用 `sizeof()` 语句查看变量的大小，使用 `alignof()` 语句查看变量的自身对齐值，测试代码：

    ``` cpp
    #include <iostream>
    #pragma pack(2)

    typedef struct test1
    {
        char c1;
        int i1;
        char c2;
    } test1;

    typedef struct test2
    {
        char c1;
        test1 t1;
    } test2;

    int main()
    {
        double d;
        test1 t1;
        test2 t2;                                   //有pack宏  无pack宏
        std::cout << sizeof(d) << std::endl;        //8         8
        std::cout << sizeof(t1) << std::endl;       //8         12
        std::cout << sizeof(t2) << std::endl;       //10        16
        std::cout << alignof(d) << std::endl;       //8         8
        std::cout << alignof(t1) << std::endl;      //2         4
        std::cout << alignof(t2) << std::endl;      //2         4
        std::cout << alignof(t1.i1) << std::endl;   //2         4
        std::cout << alignof(t2.t1) << std::endl;   //2         4
        return 0;
    }
    ```

## 为什么要内存对齐

1. CPU 在访问内存时，访问地址通常不是以字节为单位的，而是以字为单位的（32 位系统就是 4 字节，64 位系统是 8 字节）。未对齐的内存访问需要处理器进行多次内存访问（如一个 `int` 类型变量的前两字节存储在对齐地址之前，后两字节存储在对齐地址之后），而对齐的内存访问只需要一次访问。所以如果内存中的数据遵循一致的内存对齐规则，就可以提升CPU访问内存的效率。甚至在一些老平台上，CPU 根本不支持非对齐访问，遵循内存对齐规则也是为了兼容老平台。

2. 结构体要满足复杂的内存对齐规则有2个原因：

    1. 在结构体单独使用时，让结构体中每个成员变量都能满足自身对齐要求。以 test1 结构体举例，假设结构体内部成员不满足对齐规则，结构体内部就是这样的：

        ``` c
        typedef struct test1
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            int i1;     //对齐到基地址偏移量 1，占用 4，不满足其地址为自身对齐数 4 的整数倍。
            char c2;    //对齐到基地址偏移量 5，占用 1。
        } test1;
        ```

    2. 在结构体被组成数组或被嵌套在更大的结构体中时，让结构体中每个成员变量都能满足自身对齐要求。这个要求除了要让结构体内部成员满足对齐规则，结构体自身还要满足 “结构体总大小为结构体成员变量中最大对齐值的整数倍” 这个规则。以 test1 结构体举例，假设结构体内部成员已经满足对齐规则，而结构体总大小未满足规则，该结构体及其组成的数组的内部就是这样的：

        ``` c
        typedef struct test1
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            int i1;     //对齐到基地址偏移量 4，占用 4。
            char c2;    //对齐到基地址偏移量 8，占用 1。
        } test1;        //理论大小为 9，假设总大小不满足对齐规则，实际大小为 9。

        test1 t1_array[3];
        //t1_array[0]   //对齐到数组基地址偏移量 0，占用 9。
        //t1_array[1]   //对齐到数组基地址偏移量 9，占用 9，内部 i1 对齐到数组基地址偏移量 9 + 4 = 13，不满足其地址为自身对齐数 4 的整数倍。
        //t1_array[2]   //对齐到数组基地址偏移量 18，占用 9，内部 i1 对齐到数组基地址偏移量 18 + 4 = 22，不满足其地址为自身对齐数 4 的整数倍。
        ```

        当结构体被嵌套时也是与组成数组状态下具有相似的原因：

        ``` c
        typedef struct test1
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            int i1;     //对齐到基地址偏移量 4，占用 4。
            char c2;    //对齐到基地址偏移量 8，占用 1。
        } test1;        //理论大小为 9，假设总大小不满足对齐规则，实际大小为 9。

        typedef struct test3
        {
            char c1;    //对齐到基地址偏移量 0，占用 1。
            test1 t1;   //对齐到基地址偏移量 4，占用 9。
            int i1;     //对齐到基地址偏移量 13，占用 4，不满足其地址为自身对齐数 4 的整数倍。
        } test3;
        ```

    看到这里可能会有个疑问，就算结构体在声明时考虑到了这么复杂的对齐规则，但是这些对齐数值都是基于结构体基地址或者结构体数组基地址的，如果在申请结构体或结构体数组的内存时，分配的基地址本身就无法满足对齐条件呢？其实是不会发生这种事情的，下面会用 `malloc` 函数来一窥内存分配时的对齐规则。

## malloc 函数在分配内存时的对齐规则

1. 我们先看看微软官方文档上是如何描述 `malloc` 函数的：

    > malloc 会返回指向已分配空间的 void 指针，如果可用内存不足，则返回 NULL。若要返回指向类型而非 void 的指针，请在返回值上使用类型转换。返回值指向的存储空间会适当对齐，以存储对齐要求小于或等于基本对齐要求的任意对象类型。（在 Visual C++ 中，基本对齐是 double 或 8 个字节所需的对齐。在面向 64 位平台的代码中，是 16 个字节。）使用 _aligned_malloc 为具有更大对齐要求的对象分配存储空间，例如 SSE 类型 __m128 和 __m256，以及使用 __declspec(align( n ))（其中 n 大于 8）声明的类型。 如果 size 为 0，则 malloc 在堆中分配零长度的项并向该项返回有效的指针。 即使请求的内存量较小，也要始终检查 malloc 的返回值。

    其中 “返回值指向的存储空间会适当对齐，以存储对齐要求小于或等于基本对齐要求的任意对象类型” 这句话已经向我们表明了，`malloc` 函数确实会遵循一定的对齐规则来保证使用这段内存的变量满足自身的对齐要求。
    但是后半句话有个限制条件：“对齐要求小于或等于基本对齐要求的任意对象类型”，这是因为内存分配时也是根据一个基本对齐值来选择首地址的，分配的内存首地址会是这个基本对齐值的整数倍。这个基本对齐值也在描述中有体现：“在 Visual C++ 中，基本对齐是 double 或 8 个字节所需的对齐。在面向 64 位平台的代码中，是 16 个字节”。
    其实这个基本对齐值在头文件 `<stddef.h>` 中就有定义：`max_align_t`，通过 `alignof(max_align_t)` 语句就可以查看当前平台的基本对齐要求。那么为什么以这个基本对齐值来分配内存就能保证使用这段内存的变量满足自身的对齐要求呢？这是因为在绝大部分场景下，`max_align_t` 的值会大于等于任何一个普通变量的自身对齐要求，而变量的对齐要求又都是 2 的幂次方，所以只要满足了所有变量中对齐要求的最大值，就可以满足所有变量的对齐要求（除了一些专业数学运算库会使用到的拓展变量，这些拓展变量的对齐要求要大于默认普通变量，这时就需要使用 `_aligned_malloc` 函数来分配满足特定对齐要求的内存了，但是特定对齐要求依然要满足是 2 的幂次方）。对于结构体，结构体的自身对齐要求就是其成员变量中对齐要求的最大值，所以 `max_align_t` 的值也会大于等于任何一个结构体的自身对齐要求，同样满足对齐需求。

2. 虽然 `malloc` 函数已经为我们处理好了内存的首地址，可以满足大部分的内存使用场景，但还是有需要我们注意的情况。如果我们使用 `malloc` 函数分配的内存来存储一串自身对齐值各不相同的变量，那我们必须手动让第一个变量以外的其他所有变量实现对齐要求，举个例子：假设我们申请了一段 15 字节的内存，用来依次存储 int 变量，char 变量和 float 变量。首先由于 `malloc` 函数已经为我们处理好了内存的首地址，所以 int 变量是一定对齐的。char 变量的自身对齐值是最灵活的 1 字节，所以也是一定对齐的。但是到了 float 变量这里，由于 int 变量占用了 [0, 3] 的内存，char 变量占用了 [4] 的内存，float 变量的地址默认会从内存基地址的偏移 5 字节开始，这样就不符合 float 变量自身的对齐要求 4 了，所以我们要手动调整 float 变量的地址为目前可以使用的 4 的最小倍数：8。之所以要手动调整 float 变量的对齐，是因为我们如果要使用这个 float 变量，大概率是会用 `float *` 来操作这块 float 内存的，只要使用了指针，编译器和 CPU 就会遵循该指针对应的数据类型的对齐要求来操作数据，所以我们就要根据这些事项调整内存布局。
    看到这里可能会觉得这个需求很奇怪，确实，在常规场景下我们不会遇到这种需求，这其实相当于在手动构造一个未声明的结构体。不过下面提到的 lvgl 链表巧妙运用了这个技巧，实现了一种可以包含任何数据类型，还能根据实际需要自动调整大小的链表节点。

## lvgl 的链表对内存对齐的巧妙运用

1. 常见的链表有两种，一种是将数据和链表节点分开存储，然后让链表节点具有指向数据的指针，这是非侵入式链表；另一种是直接在数据中融入链表节点，这是侵入式链表。对于前者，虽然可以单独为数据申请内存，具有很高的灵活性，但是链表节点和数据需要申请两份独立的内存，增加了内存碎片和寻址时间；对于后者，虽然直接在数据内部插入链表节点可以减少寻址时间和内存消耗，但是会让数据的结构变得臃肿，还增加了数据与链表的耦合。lvgl 的链表在原理上更像是一种侵入式链表，但是它也做到了在一定程度上让数据与链表节点“分离”，这样用户就不需要在声明数据的结构时考虑到链表的存在，降低了耦合性。

2. lvgl 的链表节点没有固定的声明，它的实现就是我们上面提到的：“申请一大块内存然后手动构建结构体”，如果将这个虚拟结构体声明出来，就是这样的：

    ``` c
    typedef struct lv_ll_node_t
    {
        要存放的数据;
        lv_ll_node_t *prev;
        lv_ll_node_t *next;
    } lv_ll_node_t;
    ```

    可以发现，链表节点的第一个成员就是数据，所以指向数据的指针和指向链表节点的指针是相同的，因此只要在操作这块内存时使用相应的指针类型，这块内存就可以在数据和链表节点的角色之间随意切换（不过作为链表节点时需要用户手动操作）。
    由于每个链表节点都是一块动态申请的内存，在使用时只需要指向链表节点的指针就够了，所以 `lv_ll_node_t` 在 lvgl 中的声明是这样的：

    ``` c
    typedef uint8 lv_ll_node_t;     //只需要指针，类型就不重要了。
    ```

    这样设计的好处就是，链表节点不存在显式声明，无论数据有多大，都无需重新声明链表节点的结构就可以让链表节点存储全部数据，弥补了侵入式链表需要在数据结构中融入链表节点所导致的耦合。

3. 既然要手动构造结构体，自然要注意内存对齐的问题。由于链表节点的第一个成员就是数据，数据的对齐问题就不需要关注了（数据内部的对齐问题让用户自己处理），我们要注意的只有指向前一个和后一个链表节点的指针的对齐。在不同的平台上，指针的对齐值是不同的，所以 lvgl 会先根据每个平台具有不同的宏定义这点来判断当前的平台，进而判断指针的对齐值（我在模仿 lvgl 链表的实现时，使用的是 `sizeof(lv_ll_node_t *)` 语句来获取指针的大小，不使用 `alignof(lv_ll_node_t *)` 语句是因为考虑到 `alignof()` 语句是在 C23 和 C++ 11 标准之后才有的，会存在兼容性问题。而且在绝绝绝大部分情况下，基本数据类型的对齐值就是它的大小）。为了让指针可以对齐，需要让数据区域的内存大小适当扩大一些，如：

    ``` c
    //假设当前平台的指针是 8 字节对齐的

    typedef struct test1
    {
        char c1;    //对齐到基地址偏移量 0，占用 1。
        int i1;     //对齐到基地址偏移量 4，占用 4。
        char c2;    //对齐到基地址偏移量 8，占用 1。
    } test1;        //理论大小为 9，但需要是 4 的整数倍，实际大小为 12。

    //虚拟结构体，并不存在下面的声明，只是为了便于理解才写成这个形式的
    typedef struct lv_ll_node_t
    {
        test1 t1;               //数据大小为 12，但是为了让后面的两个指针可以 8 字节对齐，需要扩大到 16。
        lv_ll_node_t *prev;     //大小为 8。
        lv_ll_node_t *next;     //大小为 8。
    } lv_ll_node_t;             //申请内存时，申请大小为 16 + 8 + 8 = 32。

    lv_ll_node_t *n1 = malloc(32);
    test1 *t1 = (test1 *)n1;
    ```

    lvgl 也给出了如何根据指针对齐数和数据大小来计算数据区域的实际大小的公式：

    ``` c
    //当指针对齐数为 4 时，将数据大小向上调整为 4 字节的整数倍
    data_size = (data_size + 3) & (~0x3);
    //当指针对齐数为 8 时，将数据大小向上调整为 8 字节的整数倍
    data_size = (data_size + 7) & (~0x7);
    ```

    以指针对齐数为 4 时举例：
    | 原大小 | 调整后大小 |
    | :----: | :----: |
    | 1  | 4 |
    | 2  | 4 |
    | 3  | 4 |
    | 4  | 4 |
    | 5  | 8 |
    | ...  | ... |
    | 8  | 8 |
    | 9  | 12 |

    具体的 lvgl 链表实现这里就不给出了，可以直接去阅读源码，这里只是说明一下与内存对齐规则相关的基本原理。
